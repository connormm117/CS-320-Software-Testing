ðŸ§© CS 320: Software Testing and Automation
Portfolio Artifacts

Project One Files:

Contact.java

ContactService.java

ContactTest.java

ContactServiceTest.java

Project Two File:

SummaryAndReflectionsReport.docx

Together, these files demonstrate my ability to create and apply software testing strategies using JUnit, develop automated unit tests to uncover errors, and analyze testing approaches to ensure quality assurance across software projects.

ðŸ’¡ Reflection

How can I ensure that my code, program, or software is functional and secure?
To ensure functionality, I rely on unit testing and test-driven development (TDD) to verify that each class and method behaves as expected. I create test cases that cover valid, boundary, and invalid inputs to confirm the program handles all scenarios properly. For security, I follow input validation principles to prevent injection attacks or data corruption and use version control to track and secure code changes. Performing code reviews and adhering to established testing frameworks like JUnit also helps maintain integrity and reliability.

How do I interpret user needs and incorporate them into a program?
I start by analyzing requirements and user stories to understand what the end user needs from the application. From there, I break down each requirement into smaller, testable components that can be implemented and verified through code. I also think about usability and real-world workflows to ensure that features align with how users will actually interact with the software. For example, in the contact service project, I created simple methods for adding, updating, and deleting contacts so the system would remain user-friendly and efficient.

How do I approach designing software?
My approach begins with understanding functional requirements and identifying what the program must achieve. I then design classes and methods around modularity and reusability, ensuring that each component has a single clear purpose. I also plan for testing early in the design phase, ensuring that every method is written with testability in mind. This structure not only improves maintainability but also makes debugging and quality assurance easier. Overall, I aim for a balance between functionality, simplicity, and scalability.
